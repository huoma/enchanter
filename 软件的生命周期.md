# 软件的生命周期

1.  问题定义

2.  可行性研究

3.  需求分析

4.  总体设计

5.  详细设计

6.  编码和单元测试

7.  综合测试

8.  软件维护

**Q: 做好上述8个方面的技术、技巧、方法。**

\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

**A:**

**ps:** 软件的生命周期：

软件生命周期由软件定义、软件开发和运行维护(也称为软件维护)3个时期组成，每个时期又进一步划分成若干个阶段。

# 一、问题定义

关键任务：**要解决的问题是什么？**

问题定义报告（文档）：通过对客户的访问调查，系统分析员扼要地写出关于问题性质、目标工程和工程规模的书面报告。通过对客户的访问调查，系统分析员扼要地写出关于问题性质、目标工程和工程规模的书面报告。

# 二、可行性研究

关键任务：回答问题是："对于上一个阶段所**确定的问题有行的通的解决办法吗**？"

目的：是客户作出是否继续进行这项工程的决定的重要依据

可行性研究报告（文档）：经济（成本效益）、技术（技术可行）、社会（操作公共安全社会道德）

可行性研究的任务：

可行性研究的目的是用最小的代价在尽可能短的时间内确定问题是否能够解决。即可行性研究的目的不是解决问题，而是确定问题是否值得去解决，研究在当前的具体条件下开发新系统是否具备必要的资源和其他条件。它是要进步不压缩简化了的系统分析和设计的过程。在较高层次上以较抽象的方式进行设计的过程。

在明确问题定义之后，分析员应该给出系统逻辑模型，然后从系统逻辑模型出发，寻找可供选择的解法。研究每一种解法的可行性。一般从经济可行性，技术可行性，运行可行性，法律可行性和开发方案可行性等方面进行研究。

可行性研究的最根本任务是对以后的行动路线提出建议，如果问题没有可行的解，应该停止这项工程的开发；如果问题值得解，应该推荐一个较好的解决方案，并且为工程制定一个初步的计划。

可行性研究的步骤：

一般来说可行性研究有以下几个步骤：

1.复查系统规模和目标；即，确保分析员正在解决的问题确实是要求他解决的问提。

2.研究目前正在使用的系统；

3.导出新系统的高层逻辑模型；

4.重新定义问题；

可行性研究的前4个步骤构成了一个循环，即分析员定义问题，分析这个问题，导出一个试探性的解，在此基础上再次进行定义问题，再次分析，再次修改\...继续这个过程，直到提出的逻辑模型完全符合系统目标为止。

5.导出和评价供选择的方案；

6.推荐一个方案并说明理由；

在推荐的的方案中应清楚地表明的内容是：1)本项目的开发价值；2)推荐这个方案的理由；3)制定实现进度表；

7.推荐行动方案；

8.书写计划任务书：

这时要草拟一份描述计划任务的可行性论证报告。报告包含内容：1）系统概述；2）可行性分析；3）拟定开发计划；4）结论意见；综合上述分析，说明新系统是否可行，结论分为：立即进行、推迟进行、不能和不值得进行。

可行性研究的要素：经济可行性、技术可行性、社会环境可行性

1.经济可行性：经济可行性研究主要进行成本效益分析。分：成本-效益分析And短期-长远利益分析

2.技术可行性：它是最难决断和最关键的问题根据客户提出的系统功能、性能以及实现系统的各项约束条件，从技术的角度研究系统实现的肯能性。

3.社会环境可行性：即法律可行性，主要包括：政策和市场两项内容。

小结：

        在定义问题之后才进行可行性研究。通过可行性研究可以知道问题有无可行的解，进而避免了人力、物力和财力上的浪费。可行性研究所需要的成本占总成本的5%\~10%。可行性研究的目的不是解决问题，而是确定问题是否值得去解决。

# 三、需求分析

关键任务：**目标系统必须做什么**

目的：完整、准确、清晰、具体的**建立系统逻辑模型**，通常用数据流图、数据字典和简要的算法表示系统的逻辑模型，是以后设计和实现目标系统的基础。

要求：必须准确完整地体现用户的需求

需求规格说明书（重要文档）：目标系统需求、最重要的一份文档、软件所有需要做什么、最终用户验收拿此文档比较。

**需求调研的前期准备**

1.确定调研工具

选取需求调研过程中的一些辅助工具，选取要求是自己（本组）熟悉的工具， 工具最好也是要求是普通流行的，因为要考虑交流的问题。

如：原型、草绘图、WORD、EXCEL、PPT、POWERDESIGNER、STARTUML等。

这里只强调原型化方法，原型化方法就是尽可能快地建造一个粗糙的系统，这系统实现了目标系统的某些或全部功能。建造这样一个系统的目的是为了考察某一方面的可行性，如算法的可行性、技术的可行性或考察是否满足用户的需求等。如：为了考察是否满足用户的要求，可以用某些软件工具快速的建造一个原型系统，这个系统只是一个界面，然后听取用户的意见，改进这个原型。以后的目标系统就在原型系统的基础上开发。

原型主要有三种类型：探索型、实验型、进化型。

探索型：目的是要弄清楚对目标系统的要求，确定所希望的特性，并探讨多种方案的可行性；

实验型：用于大规模开发和实现前，考核方案是否合适，规格说明是否可靠。

进化型：目的不在于改进规格说明，而是将系统建造得易于变化，在改进原型的过程中，逐步将原型进化成最终系统。

在使用原型化方法时有两种不同的策略：废弃策略、追加策略。

废弃策略：先建造一个功能简单而且质量要求不高的模型系统，针对这个系统反复进行修改,形成比较好的思想，据此设计出较完整、准确、一致、可靠的最终系统。系统构造完成后，原来的模型系统就被废弃不用。探索型和实验型属于这种策略。

追加策略：先构造一个功能简单而且质量要求不高的模型系统，作为最终系统的核心，然后通过不断地扩充修改，逐步追加新要求，发展成为最终系统。进化型属于这种策略。

2.调研项目前期情况

对象：售前人员、商务人员、项目经理；

内容：招标书、答标书、合同、以及其他与用户交流的口头或书面材料（包括宣传、承诺等）

甲方行业情况的了解、最好看一些行业方面的书籍，学习业务领域知识。

了解客户、项目的背景，如果事先客户给过类似的《软件初步思路》之类原始需求文档，那么首先弄懂这个文档，了解客户的目的，为什么要做这个软件，主要想解决什么问题，涉及的业务有哪些等等，这些调研准备的基础。

根据了解的初步用户需求，分析可能的难点在什么地方，列出这些难点。做到心中有数，并且记录前面了解需求的过程中不明白的地方，便于到现场后及时和客户沟通。

3.建立需求调研规范

一定建立一个专门的设计环境（文档目录）来为本项目服务，进行一定的资源分配，进行必要的文件管理。

(1).统一项目所用工具

(2).统一项目文件模版

(3).其它资源列表（资料，相关网站，资询电话）

4.明确客户方组织结构

用户单位的组织机构是什么，哪些部门和人员岗位参与本系统的使用？上下级关系如何？为项目组建立起外部联系通讯录。

了解客户的组织机构，涉及软件使用的部门，参与调研的部门和人员，客户关键人是谁等等，尽可能获得客户上层的支持，自上而下的开展需求调研会使调研工作更容易推动。客户需求小组成员要尽可能多的代表客户不同的用户层次。

5.制定项目的调研计划

调研计划制定目的：对调研活动序列进行划分、评估、资源分配。

在制定计划时考虑到分析时间。计划在公司内部评审通过后，及时提交给客户，让客户对调研计划有充分的了解。

调研计划包含的内容：

(1).调查什么？通过什么方式调查？何人何时调查？

(2).明确项目组人员分工（培养我们的专家）

(3).调研中大家遵循的约定（如：需不需要签字？何时召开例会等）

(4).针对需求中的功能模块，客户方有明确的唯一配合联系人

注意事项：

项目任务书下达给后，项目经理及调研人员应该对合同中软件范围认真审阅，虽然只大概写了需求范围，但这些信息及为重要，它是调研计划制定的一个依据。

计划制定后最好召开项目启动会议，相关领导和业务部门参与，确定双方项目组成员，确定客户方的配合人（唯一联系人）、领导（唯一协调人），介绍项目组的人员安排、总计划、需求调研计划将行程和计划通知客户.

**需求调研内容**

1.需求调研要收集的内容

需求分析报告的读者有客户、设计人员、开发人员，在编写时一定要考虑到文档的可读性。需求调研形成的成果具体如下：

(1).收集用户需要产生的单据和报表 ；表单及报表的适用对象；

(2).画出业务流程图，并认真检查和核对每条路径中是否完备，异常情况怎样处理（系统的动态特性）；

(3).依据流程图收集每个步骤需要的使用和操作的数据，确定数据的类型和范围（系统的静态特性）；

(4).画出业务实体及其关系，并估计业务实体的产生频率和数据量；

(5).评估业务流程和实体中需求变化的可能性；

(6).用户权限；

(7).信息系统建设现状；

(8).收集用户对系统界面风格、版式、颜色的偏好和需求；

(9).对系统将来使用的硬件、操作系统、网络情况进行了解；

(10).收集系统初始化数据，或者要求客户进行收集和整理，明确期限时间；

(11).编制简单界面原型（该步骤也可放在需求分析之后完成，再次和用户进行沟通）;

2.需求调研成果

(1).《需求规格说明书》

(2).系统详细原型

**做好需求调研**

1.要做什么就要先了解什么

如果对客户业务不熟悉，在调研前要先做好充分的准备。

如果做的项目是你所不了解的行业（专业），最好要有专家------最终用户做专家是最好的，调研要了解这个专业，不是要你成为专家，但最少要了解一定的专业知识（最少专来词汇你要知道），否则就不知道去问什么或如何去问他们，甚至于人家在说什么你也不知道。

相应的专业资料是必须的，最少要有专业入门书籍和对应的资料，也需要更深入的一些资料。当然有专家的参与就另当别论。

如果行业的难度不是很大，可以通过分析人员的自我学习在短时间内了解行业，也许可以不用专家，否则专家是必须的。

2.采用多种手段挖掘需求

重视调研资料的准备：调研资料（Rose图、Ppt、原型准备）一般客户图形化界面感兴趣，最好是采用图的方式把东西展示给用户，可以意思转换为用例图、用户界面、流程协作图、状态图等。

需求调研过程有选择的确定调查方式，例如：

1).与客户交谈，向用户提问题;

2).参观用户工作流程，观察用户操作;

3).向用户发调查问卷;

用户通常没有耐心回答论述题，所以应当以选择题和是非题为主。

4).与同行、专家交谈，听取他们的意见;

5).分析已经存在的软件产品，提取需求;

6).从行业标准、规划中提取需求;

7).上网搜索相关资料

3.站在用户的立场上考虑系统功能

1).设身处地的成为用户，考虑适用型和用户体验；

2).用户的语言与用户交流;

3).总结以往的实施经验，提出建议;

4).总结以往的实施经验，引导需求;

\*以上各条也是尽量减少需求变更的手段之一；

4.5W + 1H方法

5W：why、what 、who、when、where

1H：How to accomplish(实现) the system?

WHY定律：WHY就是为什么用户要引入系统，引入新的信息系统对用户有什么帮助，在总体工作效能上如何实现一个最终的结果？WHY定律是要求在需求开始时，项经理就应该明确的，这个项目是为了改进用户工作效率；提高部门间的协作机制；加快对客户反应的体系服务；提升企业的竞争力等等。有了这么一个WHY引入思想，项目经理就可以理清用户最终要的是可以提供给他们什么样的系统，在系统的定位和建立上，就有一个明确目标。

WHAT定律：有了一个总体的目标性，从各业务流程的要求入手，引入第二个W定律\_\_-WHAT定律，WHAT则是这个系统要做什么？实现什么？提出各业务流程问题、流程局限性问题、系统要解决的问题等，在这个WHAT的基础上，把系统划分成各功能模块，逐步弄清模块流程需求、功能需求、结构需求。引入WHAT定律可以让我们了解到系统的初步需求。

WHO、WHEN、WHERE定律：这个阶段是需求细化阶段，在WHAT定律的基础上，细分系统的用户需求：分析什么人，在什么时间，什么阶段可以或必须操作这个功能，结合前面的WHAT定律，理清系统的流程阶段划分，记录并分析系统功能实现的细节，在这个阶段就可以产生系统需求的用例图（Use Case），作为下阶段设计的依据。

HOW定律：就是怎样实现系统了，在前面的WHY、WHAT、WHO、WHEN、WHERE基础上，已经搭建了一个非常好的系统需求基础框架，如何在这些用户需求的基础上，分析系统的需求，如何进行需求规格的分析与下阶段的设计、实现工作，就是How to accomplish(实现) the system?

引入这5W+1H的定律，在一定程度上保证了系统需求的准确性，使得项目经理或需求分析人员可以有序、有条理地开展需求挖掘和调研活动，这样的安排用户在配合上也非常清晰，知道如何与项目人员配合。

5.需求调研注意事项

(1).按照计划有步骤的调研

提前约定调研活动的计划，达到的目标，时间安排，参与的人员，并根据用户安排，适当调整计划。最忌参加会议时目标不明确、汇报人员不明确。

按照事先和客户商量好的调研计划稳步进行，如果现场临时出现变化，比如参与调研的客户临时有事，或者调研的内容出现变化，那么及时和客户确定新的调研安排，列出总的调研顺序。切忌想到哪说到哪，调研内容杂乱无序，很有可能就会出现遗漏而不能及时发现。

(2).掌控调研进程，推动调研工作顺利进行

因为调研工作实际就是和客户聊天谈话，很可能就会经常跑题，越扯越远，另外客户的精力一般也容易不集中，跑神，这时候，调研人员要能够掌控整个进程，什么时候及时把客户的思路拉回到正题上，什么时候适当的聊聊其他的话题调节气氛，都需要调研人员灵活掌握，总之一个目的，尽快的推动调研工作朝前进行。

(3). 认真仔细的倾听，及时的记录

仔细的倾听就是要明白客户的完整的表达，不要觉得有些你已经懂了，经常打断客户来急切表达自己的看法，每次在客户完整的把话说完再表达自己的想法。及时记录涉及客户业务、实际工作、客户想法的内容，不能以为当时听明白了就不去记录。一定要有记录的习惯，谈上几个小时，很多细节是记不住的。

(4).先了解宏观需求，再了解细节需求

遵从由总到分、由粗到细、由简单到复杂的调研过程，无论是让客户介绍他们的业务还是谈他们的想法，都要先从总的大的方面说起，然后再是细节。如果直接进入细节，往往并不能很好的抓住他的要点，不能把握总体的要求。

(5).挖掘客户最原始的需求，而不是仅仅只是记录

客户跟你说的内容只是他的一个理解，他的理解可能也有偏差，而且现在有的客户因为对软件比较了解，往往告诉你的不是需求，而是他的设计思路，比如直接跟你说"你做个这样的功能，我一点就能出来什么什么"，对我们来说，就需要多问几个问什么，"你为什么会这样做呢？""你想看的结果是什么呢？目的是什么呢"等等，一定要想办法了解到客户没有经过转化的最原始的需求，因为往往很多时候客户告诉你的他的想法并不能实现他原本的目的，而他以为能实现，所以就直接告诉你想法。需求调研人员如果没有了解到最原始的需求而只是把客户的想法记录下来，那么就会出现做出来的东西解决不了客户实际的问题。

这个过程往往同时也能够帮助我们缩小需求范围，比如客户开始想的好好的一些功能，但是在我们深入分析思考后发现因为存在某些问题这些功能无法实现，或者即使实现也会大幅增加工作量比开始想象的复杂的多，那么在这样一个基础上说服客户放弃这个想法。这也是在合同额确定的情况下砍功能的一种方式。

(6).引导客户的潜在需求

大部分客户对自己要做成一个什么样的软件并没有一个完整的规划或者想法，很多时候都是在谈的过程中逐步的清晰。调研的过程也不会是客户滔滔不绝的谈他的想法，而是靠你一点点的去问客户，那么到底问什么，就需要你掌握，除了不懂的业务以外，重要的是在已经了解的客户需求的基础上分析、扩展，带出其他潜在的客户没有说出来的需求。比如说客户想做一个领用办公用品的功能，开始想的很简单，填一个领用申请，一审批就行了，但是经过仔细分析后，就会衍生出"物品管理""类别管理""库存管理"等潜在需求。如果不考虑这些，那么无论是你还是客户都会认为这个功能很简单，那么对完成时间和工作量的估计都会出现问题。防止出现在做系统设计甚至是开发时才发现"当时没想到这个地方没那么简单，还需要再跟客户沟通一下"这种情况。

这里面，潜在需求如果细化的话还分为两个部分：1）系统必须的；2）系统不必须的。"必须的"就是像上面例子一样，如果不挖掘潜在需求，客户已经提出的需求就无法实现，就是把看上去简单的复杂问题，实际上他还是个复杂问题。"不必须的"，就是对已经提出的客户需求影响不大，相对独立，相当于再和客户沟通的过程中又了解到的新的需求。对这部分，就需要根据调研时项目的合同额是否确定，工作量大小，和客户的关系如何等等有需求调研人员灵活掌握，可以提也可以不提。但是提出就肯定会增加工作量和系统的复杂度。

(7).规避客户不合理的要求和较难实现的要求

客户需要的不一定的是客户真正所需要想要的。客户永远没有错，错的只有我们没有真正理解客户的需要。

调研时要把握主题的能力，分清有用功能、可选功能用、无用功能及不可实现功能，及时表达我们的观点，让谈话接近主题。

调研的过程中，不可避免的会出现客户提出一些我们现有条件下根本无法实现或者即使实现也非常困难的要求。这种情况就需要需求调研人员的聪明的头脑和快速反应能力，同时也需要调研人员的良好的沟通技巧，要能巧妙地说服客户放弃这种方式并且还要客户能够理解，而不致认为你在逃避问题不想解决。一般可以采取这些方式：1）客户提出这些要求后能马上了解客户提出这个要求的真实目的，然后快速思考出另外的简单的方式同样能实现客户的这个目的。这是最好的方式；

2）必要时直接告诉客户无法实现并且给出合理的理由，特别是在客户说某某系统已经实现了这个方式时，比如他们用的是什么什么平台支持，这个平台支持需要另外付费等等；

3）直接告诉客户虽然能实现，但是需要很大的精力和成本，而这个可能是客户无法承受的，当然你一定要能说出客户听起来合理的理由。

这些都不是绝对的，需要调研人员丰富的软件开发经验和灵活的头脑较好的表达能力临场发挥。

(8).注意需求调研的覆盖面，防止需求不具代表性

需求调研开始时，客户明确的唯一配合联系人既是我们每个模块的一把手！我们要做的就是"拿着鸡毛当令箭"！找对人才能办好事。

同时也要防止提供需求的客户方面只有一个人，使实际软件需求变成个人需求。受制于这个人的所处层次，以及掌握的业务知识，与领导意图的符合度等等限制，给我们带来较大的需求风险，稍有不慎就会给后面软件需求变更埋下伏笔。避免这种风险，一方面调研人员依据以往的经验和业务知识自己判断客户提出的需求是否合适，有没有过于强烈的个人特征等等，另一方面，在调研开展的最初想办法和客户的上层明确类似风险的存在，让客户领导在人员安排上避免这种情况，同时也是让他明白会存在这种情况，以后一旦真的出现，客户也不会说是我们的责任。

(9).及时总结整理已经完成的调研内容

需求调研、相关会议纪要及时转发，及时总结成果，让客户听听你的理解是否他们提的需求一致。

每次调研回去后，及时把白天调研的内容及时整理出来，当时没来的急记的内容及时补记，同时再深入的分析、过一遍，确保有没有遗漏的问题，列出所有的疑问待到第二天调研时询问客户。

定期汇总的成果：什么情况下？什么人？做了什么决定？产出了什么？

(1).警惕不明确因素

实现某一个功能的前提条件是什么？如果没有哪个先决条件，哪些工作是无法开展的？责任划分清楚。

(2).成本，成本还是成本

高水平的设计师高就高在设计出"恰好"满足客户需求的软件，并且在开发方和客户方获取最大的利益，而不是不惜代价设计出最先进的软件。

(3).避免片面听取了某些用户的需求而忽视其他用户的需求

**成功的需求调研**

1.需求规格说明书具备的特性

正确、清楚、无二义性、一致（各个需求之间不产生矛盾）、必要（不画蛇添足增加开发成本）、完备（不遗漏必要的功能如权限配置）、可实现性、可验证性（提供交付依据）、明确优先级（不被细节拖死比如UI）、阐述"做什么"而不是"怎么做"。

2.覆盖合同中所有合理的需求

对待需求工程的态度可以分为"被动型"、"主动型"和"领先型"三种，只有后两种才有可能开发出成功的产品。

在实际工作中，可以建立合同与需求规格说明书对应章节对应表、合同与软件功能对应表。时刻提醒需要提供实现的业务范围。

3.成本风险在控制之内

4.挖掘潜在的需求

适当站在商务的立场上思考，为项目的寻找出路，申请更多的财力物力。

七、签字画押

我们编写完的需求分析报告，最终要展示给客户，让他们对我们的分析结果进行认可。其实这个过程非常重要，对于客户和我们同样的重要。将业务需求与用户进行确认（采用会议讲解的方式），用户领导签字。 这个挺难的。

**需求调研人员能力**

1.熟悉客户业务

对于客户主要想让软件来解决他哪一部分的业务，事先最好能通过一些手段尽可能多的了解。即使事先并不能非常深入，那么也要利用调研的机会尽可能多的了解，调研完成后，没有理由你不是个半个业务专家。

2.熟悉软件开发

调研的过程中一方面你要随时对客户提出的要求的合理性、难易性作出判断，同时你还要在客户想法不成熟时提供给客户好的实现方式，这一切都需求你对软件开发非常熟悉，很多时候，需求调研人员至少曾经是一个优秀的软件开发人员。因为随着用户使用电脑的增多，对各种软件有一定的了解，往往会直接提出一些功能要求，比如在任务发起时提出需要给多人发送，那么对这样的一个功能会对我们的设计和开发有什么样的影响，那就需要现场需求调研人员根据自己的经验作出判断，然后思考出有利于自己的方式并巧妙的说服客户接受。

3.头脑聪明，反应敏捷

对客户表达的内容要能很快的、充分的理解，并且能迅速的思考及时应对。同时因为客户的水平也有高低，特别是对那些不善表达的客户，更需要你从不清楚的表达中分析出实质。

比如对于税务系统预警的调研，客户本身事先并没有完善的预警规则，很多都是调研现场临时思考出来的，那么这样的一个规则敲定后，你敢拿这样的内容去设计开发吗？那么就需要调研人员根据掌握的业务知识，在现场时及时根据客户提出规则迅速的在脑子里发散、扩展、分析、思考，找出规则是否还有漏洞，和客户继续深入探讨下去。

4.善于表达，思路清晰

能够把你的想法清晰的传达给客户，特别在一些难以理解的地方，能够灵活的用各种可能的方式让客户明白你的意图。当你在解释半天客户都没有明白的时候，一定要想想你在什么地方没有解释清楚了。

5.善于观察，精于总结

和客户打交道的过程中，善于观察每个细节，分析这些细节是否对你的工作有影响，每次阶段性调研完成后及时总结，来帮助更好的进行下一次的调研。比如在调研间隙观察客户的实际工作内容和工作流程，攀谈了解相关情况，观察客户是否还在使用其他系统，了解其他系统的情况；观察客户群体中的关键人物；观察客户各有什么爱好、特点等等。当天调研完成后，及时回顾整理一天的调研内容，筛选出疑问，便于第二天调研时向客户了解清楚。

6.善于记录，文笔流畅

一直强调，在客户现场，把你听到的看到的能记多少就记多少，尽可能的多记，，特别是客户在讲述自己实际的工作业务工作内容和方法等时，不要管他回去以后有没有用，千万不能因为当时听明白了就不记了，即使一时没有时间，那么事后也要及时补记下来。这些一手材料里有很多都是能够帮助你和没有参加调研的人理解业务需求的内容。防止出现，1）当时听明白了但没记录的内容，回来后某些细节又忘了；2）当时虽然记了，但写的内容太简单，回来后看当时记得内容已经想不起来是怎么回事了。

# 四、总体设计

关键任务：**怎样实现目标系统**

根据需求设计方案，分析推荐最佳方案，设计软件结构等。**设计程序的体系结构**，确定程序有哪些模块组成以及模块之间的关系

总体设计说明书（文档）：记录总体设计结果

**总体设计阶段两个阶段**

1.系统设计阶段：确定系统的具体实现方案

划分出组成系统的物理元素------程序、文件、数据库、人工过程和文档等.

设计系统的结构,也就是要确定系统中每个程序是由哪些模块组成的,以及这些模块相互间的关系

2.结构设计阶段：确定软件结构

**三层结构**

表达层: 控制怎样把数据通过用户界面显示给用户,同时接受用户的交互输入

业务层: 把跟这个应用相关的业务流程和业务规则集中在一起形成一个独立部分

数据层: 负责与数据库打交道,把数据库中的表,记录等细节隐藏起来,使业务层见到的是普通的函数或者数值对象

关系：表达层(表达逻辑)\<\-\-\--\>业务层(业务逻辑)\<\-\-\--\>数据层(数据存储)\<\-\--\>数据库

**雪球理论**

从坚实的内核做起: 雪球起点不是一堆散雪而是捏了又捏的很紧密的雪核

从小到大慢慢来: 一点一点由小变大,而不是通过一次性组装变大

边滚边看边调整: 不能朝一个方向一直滚下去,往往是看着哪个缺了,重新换个方向继续滚

任何时候都接近圆: 任何时候滚出来的都是圆(及早集成,这样在开发中遇到的困难就越小)

**总体设计阶段的工作步骤(七步)**

·提供多种可能实现的方案.

·选取合理的方案.

·推荐最佳的方案

·对程序的结构设计：确定程序由那些模块组成,模块需要完成那些适当的子功能,以及模块之间的关系（至于过程设计属于详细设计阶段的任务.过程设计：确定每个模块的处理过程 ）

·设计数据库

·制定测试计划

·书写文档：计入总体设计的结果(文档总类: 1.系统说明 2.用户手册 3.测试计划 4.详细的实现计划 5.数据库设计结果)

**结构设计**

要求:结构设计简单明确

体系结构:在保证能够完成系统目标的前提下,减少不必要的中间层次和模块,能够直接通话的尽量直接通话,除非非常有必要.别人的东西不要在重复一遍,吧系统的规模保持在最小的程度.同时注意除去多余的联系和耦合

类结构:类结构的设计的继承关系应该经过仔细推敲,真正反映普遍和特殊的关系,同时在数量上是精简的,在继承结构上是扁平化的

数据结构:数据结构做到精简成员变量意义明确,提高算法效率高减少功能作用类似的局部变量

概念的一致性:在整个设计中使用统一,连贯的系统分析法,角度,和一致性的平衡尺度,直到在每个部分使用同样的类比和词汇

**模块划分**

\--模块划分首先要有合理性,有助于对模块的认识和理解

1)种类:

基于逻辑关系(例:分层结构的层次间的依赖关系)

基于功能

2)判断划分的好坏:

看模块之间的耦合程度和方式,越少越好,越简单越好.有适当的依赖是件好事,证明模块之间有共享和复用,但不可取的是\"你中有我,我中有你\",以致模块如一堆乱麻彼此分不开来.做到能不耦合在一起就尽量分开来,能不相互依赖就不要相互依赖

**应该遵守原理**

1.模块化:把程序划分为若干个独立的访问且完成一个子功能的模块,且把这些模块集合起来变可以满足用户所需求的功能.

2.模块化好处：

使软件结构清晰,不仅容易设计也容易阅读和理解.

容易测试和调试,提高软件的可靠性.

提高软件的可修改性.

有助于软件开发工程的组织管理.

3.抽象：把这些相似的方面集中和概括起来,暂时忽略它们之间的差异,这就是抽象.或者说抽象就是考虑事物间被关注的特性而不考虑它们其他的细节.

4.逐步求精:

为了能集中精力解决主要问题而尽量推迟对问题细节的考虑.因为每次面临的因素太多,是不可能做出精确思维的.处理复杂系统的唯一有效的方法是用层次的方法构造和分析它,把精力集中在与当前开发阶段最相关的那些方面上,而忽略那些对整体解决方案来说虽然必要的,然而目前还不需要的细节.每一步对软件解法的抽象层次的一次精化.

5.信息隐藏和局部化：

应该这样设计模块,使得一个模块内包含的信息对于不需要这些信息的模块来说,是不能访问的.把一些关系密切的软件元素物理地放得彼此靠近.优点\-\--如果在测试期间和以后的软件维护期间需要修改软件不会把影响扩散到别的模块.

6.为何软件设计中应该追求尽可能松散的系统?

这样的系统中可以研究、测试和维护任何个模块,不需要对系统的其他模块有很多了解.模块间的偶合程度强烈影响系统的可理解性、可测试性、可靠性和可维护性.

**耦合**

定义:是指不同模块彼此间互相依赖的紧密程度；

耦合的分类(五类)：

数据耦合: 如果两个模块通过参数交换信息,而且交换的信息仅仅是数据,那么这种耦合就是数据耦合.

控制耦合: 如果两个模块通过参数交换信息,交换的信息有控制信息,那么这种耦合就是控制耦合.

特征耦合: 如果被调用的模块需要使用作为参数传递进来的数据结构中的所有数据时,那么把这个数据结构作为参数整体传送是完全正确的.但是,当把整个数据结构作为参数传递而使用其中一部分数据元素时,就出现了特征耦合.在这种情况下,被调用的模块可以使用的数据多于它确实需要的数据,这将导致对数据的访问失去控制,从而给计算机犯错误提供机会.

公共环境耦合: 当两个或多个模块通过公共数据环境相互作用时,他们之间的耦合称为公共环境耦合.

内容耦合: 有下列情形之一,两个模块就发生了内容耦合

一个模块访问另一个模块的内部数据

一个模块不通过正常入口而转到另一个模块的内部

一个模块有多个入口

在进行软件结构设计时,应该采用的原则：

尽量使用数据耦合,少用控制耦合和特征耦合,限制公共环境耦合的范围,完全不用内用耦合.

**内聚**

定义:是指在模块内部各个元素彼此结合的紧密程度.

内聚的分类(大三类,小七类)：

1、低内聚

（1）偶然内聚：如果一个模块完成一组任务,这些任务彼此间即使有关系,关系也比较松散,就叫做偶然内聚.

（2）逻辑内聚：如果一个模块完成的任务在逻辑上属于相同或相似的一类,则称为逻辑内聚.

（3）时间内聚：如果一个模块包含的任务必修在同一段时间内执行,就叫时间内聚.

2、中内聚

（1）过程内聚：如果一个模块内的处理元素是相关的,而且必须以特定次序执行,则称为过程内聚.

（2）通信内聚：如果模块中所有元素都使用同一个输入数据和产生一个输出数据,则成为通信内聚.

3、高内聚

（1）顺序内聚：如果一个模块内的处理元素同一个功能密切相关,而且这些处理必须顺序执行,则称为顺序内聚.

（2）功能内聚：如果模块内所有处理元素属于一个整体,完成一个单一的功能,则称为功能内聚.

4、内聚在设计中的要求:

设计时力争做到高内聚,并且能够辨认出低内聚的模块,有能力通过修改设计提高模块的内聚程度降低模块间的耦合程度

**软件结构设计的启发式规则(七点)**

1、改进软件结构提高模块独立性.

2、模块规模应该适中.

3、深度,宽度,扇出和扇入都应适当.

深度: 表示软件结构中控制的层数,它往往能够粗略的标志一个系统的大小和复杂程度.

宽度: 是软件结构在同一层次上的模块总数的最大值.一般来说,宽度越大系统就越复杂.

扇出: 指一个模块直接调用的模块的数目,经验表明,一个设计的好的典型系统的平均扇出通常是3或4个,太多或太少都不好.

扇入: 指一个模块被别的多少个模块直接调用.扇入越大越好.

4、模块的作用域应该在控制域之内

5、力争降低模块接口的复杂程度

6、设计单入口单出口的模块

7、模块功能应该可以预测:

如果一个模块可以当作一个黑盒子,也就是说,只要输入相同的数据就能产生同样的的输出,这个模块的功能就是可以预测的.带有内部"存储器"的模块的功能可能是不可预测的,因为它的输出取决于内部存储器的状态.由于内部存储器对于上级模块是不可见的,所以这样的模块既不易理解又难于测试和维护.

以上的启发式规则多数是经验规律,对改进设计,提高软件质量,往往有重要的参考价值；但是,他们既不是设计的目标也不是设计时应该普遍遵循的原理.

**设计优化**

1、考虑设计优化问题时应该记住"一个不能工作的'最佳设计'的价值是值得怀疑的".

2、应该在设计的早期阶段尽量对软件结构进行精化.可以导出不同的软件结构,然后对他们进行评价和比较,力求得到"最好"的结果.这种优化的可能是把软件结构设计和过程设计分开的真正优点之一.

3、结构简单通常即表示设计风格优雅,又表明效率高.设计优化应该力求做到在有效的模块化的前提下使用最少量的模块,以及在能够满足信息要求的前提下使用最简单数据结构.

4、优化时遵守一句格言："先使它能工作,然后再使它快起来."

# 五、详细设计

关键任务：**该怎样具体实现系统？**

 对概要设计中表述的各模块进行深入分析等，其中需要包含**数据库设计说明**

详细设计说明书（文档）：用适当表达工具表达算法和数据结构

**详细设计的基本任务(六点)**

1)为每个模块进行详细的算法设计.\
2)为模块内的数据结构进行设计.对于需求分析、概要设计确定的概念性的数据类型进行确切的定义.\
3)为数据结构进行物理设计,即确定数据库的物理结构.\
4)其他设计：

-   代码设计.

-   输入/输出格式设计.

-   人机对话设计.

5)编写详细设计说明书.\
6)评审.

**对总体设计划分出来的功能进行算法设计时注意的事项(八项)**

1. **性能要求**:包括对精度、灵活性和时间特性的要求.\
2. **输入项**:给出对每一个输入项的特性(名称、标识、数据的类型和格式、数据值的有效范围、输入的方式.数量和频度、输入媒体、输入数据的来源和安全保密条件等等)\
3. **输出项**:给出对每一个输出项的特性(名称、标识、数据的类型和格式,数据值的有效范围,输出的形式、数量和频度,输出媒体、对输出图形及符号的说明、安全保密条件等等)\
4. **流程逻辑**:用图表（例如流程图、判定表等）辅以必要的说明来表示本程序的逻辑流程.\
5. **接口**:用图的形式说明本程序所隶属的上一层模块及隶属于本程序的下一层模块、子程序说明参数赋值和调用方式,说明与本程序相直接关联的数据结构(数据库,数据文卷)\
6. **存储分配**:根据需要,说明本程序的存储分配.\
7. **注释设计**:

-   加在模块首部的注释；

-   加在各分枝点处的注释；

-   对各变量的功能、范围、缺省条件等所加的注释；

-   对使用的逻辑所加的注释等等.

9.  **限制条件**:说明本程序运行中所受到的限制条件.

**人机界面设计/用户接口设计**

**四个重要问题：**

1)**系统响应时间**:

定义:

用户完成某个控制动作到系统响应的时间.它有两个重要属性:**长度**(响应时间长度) 与 **易变性**(响应时间相对于平均时间的偏差)

2)**用户帮助设施**:

定义:

用户遇到复杂问题时需要查看用户手册寻找答案的设施

分类:

-   -   集成软件帮助设施(一开始就设计在软件中)

    -   附加软件帮助设施(在建立系统后在添加到软件中)

    -   \[ *普遍认为集成的帮助设施优于附加的帮助设施 *\]

具体设计帮助设施时候需要解决的问题:

-   -   **是提供部分帮助信息还是提供全部帮助信息?**

    -   **用户如何请求帮助?**one.帮助菜单,two.特殊功能键,three.HELP命令

    -   **是否在任何都能请求到功能的帮助信息,请求到的帮助信息是提供部分还是全部?**

    -   **怎样显示帮助信息?**one.独立的窗口,two.在屏幕固定位置,three.简短提示

    -   **用户怎样回到正常交互方式中去?**one.按屏幕的返回按钮,two.功能键

    -   **如何组织帮助信息?**one.平面结构(所有信息都靠关键字访问),two.信息的层次结构(用户在该结构可以查到更纤细的信息),three.超文本结构

3)**出错信息/警告处理**:

定义:

用户在和机子交互的过程中给出的\"坏消息\".

出错信息/警告消息需具备那些特性:

-   -   用用户可以理解的术语描述问题

    -   提供有助于从错误中恢复的建设性意见

    -   应该指出错误可能导致的那些负面后果,以便用户检查是否出现该问题.并在确定出现问题时候及时解决.

    -   信息可以伴随着听觉上视觉上得提示(如发出警铃,或者用明显的颜色标明出错误)

    -   信息不能带有指责色彩,不能责怪用户

4)**命令交互**:

定义:

用户通过命令行与系统交互

提供命令行用系统交互时候需要考虑的问题:

-   -   **是否为每个菜单项都有对应命令?**

    -   **采用何种命令形式?**one.控制序列(Crrl+字母键),two.功能键,three.输入命令

    -   **学习和记忆难度大小?**

    -   **忘记命令怎么办?**

    -   **用户可以自定或缩写命令?**

**三个设计指南:**

1)**一般交互指南**:

-   保持一致性:在人机界面中交互中使用一致的格式

-   在执行一个较大破坏的动作前要用户确认（如删文件,覆盖信息,终止一个程序等）

-   减少两次操作之间用户需要记忆的信息量

-   减少用户未完成磨一动作按键次数,鼠标移动距离.尽量避免用户出现问\"这是什么意思\"的情况

-   按功能对动作分类,并据此设计屏幕布局

-   用简单动词/动词短语作为命名

-   允许犯错:系统能保护自己不受严重错误的破坏

2)**信息显示指南**:

-   只显示与当前相关的信息

-   显示的信息含义明确简短

-   使用窗口分隔不同类型的消息

-   用模拟显示的方式显示消息(显示炼油厂储油罐的压力,如果用数字表示就没有用温度计形式的表示来的效果好)

-   高效率的使用显示屏(当使用多窗口时,至少让每个窗口有一点空间来显示其一部分)

-   不应用大量的数据流淹没用户(可以使用图像/图表来取代大量表格)

3)**数据输入指南**:

-   减少用户为完成一个动作,多次输入相同数据或填大量的次要信息(提供默认值).和跳过不必要的动作

-   交互方式灵活,可以调整,供用户选择自己喜欢的交互方式

-   屏蔽当前动作语境中不使用的命令

-   保持信息显示和数据输入的一致性

**Jackson设计方法**

**说明:**

Jackson 设计方法是一种面向数据结构的软件设计方法, Jackson 分析方法是面向数据流的分析方法.

**一般通过以下五个步骤来完成设计：**

-   分析并确定输入数据和输出数据的逻辑结构,并用J ackson 结构图来表示这些数据结构

-   找出输入数据结构和输出数据结构中有对应关系的数据单元

-   按以下的规则由输入、输出的数据结构导出程序结构

    -   为每一对在输入数据结构和输出数据结构中有对应关系的单元画一个处理框

    -   为输入和输出数据结构中剩余的数据单元画一个处理框

    -   所有处理框在程序结构图上的位置,应与由它处理的数据单元在数据结构 Jackson 图上的位置一致

    -   必要时,可以对映射导出的程序结构图进行进一步的细化

-   列出基本操作与条件,并把它们分配到程序结构图的适当位置

-   用伪码写出程序

**编程接口设计的五项基本原则**

-   **简洁明了**: 接口的命名和参数应该简单清楚,让人一看就知道要做什么,输入和输出大概是什么

-   **直来直去**: 接口的实际输入输出,除了名称,传入参数和返回值以外,没有别的隐含在背后的输入输出和假设条件.

-   **基本类型**: 在接口定义中使用的数据类型尽可能的使用语言本身支持的基本数据类型

-   **笼统输入**: 要求输入的参数的类型尽量笼统,具体的说,就是有父类则用父类类型,如果有实现的接口就用实现的接口类型,这样一来,该接口也笼统了,适用面也扩大了,威力也马上不一样了,一个接口可以当好几个具体接口来使用.

-   **具体返回**: 返回的类型是越具体越好.道理其实很简单,有了具体的对象,接口调用者可以随时转换成父类类型或者实现的接口类型

*对外公布的公开编程接口不能随意修改.所以在设计的时候要认真谨慎设计*

**Unix 开发哲学**

-   只要可行,一切都应该做成与开源和目标无关的过滤器

-   数据流应尽可能文本化(这样可以使用标准工具来查看和过滤)

-   数据库部署和应用协议应尽可能文本化(让人可以阅读和编辑)

-   复杂的前端(用户界面)和后台应该清楚的分隔开

-   如果可能,用 C 编写前,先用注释性语言搭建原型

-   当且仅当只用一门语言编程会提高程序复杂度时,混用语言编程比单一语言编程来的好

-   宽收严发(接收的东西要包容,对输出的东西要严格)

-   过滤时,不需要丢弃的信息绝不丢

-   小就是美.在确保完成任务的基础上,程序功能尽可能少

**线程与进程问题**

**注意:**

不同的进程之间的接口,不能传递指针类型的数据,这点在设计分布式系统和多进程系统时候要特别注意

**同步还是异步?**

同步犹如打电话直接交流有事情当场了解清楚才结束,异步犹如发邮件只要把信息发到目的地就好;当遇到资源紧缺,或者遇到长时间的操作时候多用异步.但遇到要及时的信息交流是用的是同步

**调用函数的重入:**

指的是一个线程调用一个函数的过程中.另一个或多个线程也在调用这个函数.如果该函数中有静态的数据或者一个指向静态数据的指针,就等于多个进程对一个数据在进行操作.这样做容易导进程错误

**变量可见度:**如线程 A 修改了某个变量 X 后,该变量可能被缓存在中央处理器中的寄存器中,并没有被返回到主内存中,这个时候如果 B 线程要读取变量X的数值话,很自然的是到内存当中去读取所以现在的变量X显然不是最新的值.

**代码的注释**

**常犯的毛病:**

-   啰里啰嗦讲怎么做{例:count++ //increase count by one}

-   注解写的和代码所做的就是两码事

**正确的有效注解:**

-   要注释就注释这是在做什么和为什么这么做

-   最好少注释,或者干么就没注释

**隐含规则**

-   **接口使用顺序**: 不同软件接口可能会在顺序上有一定要求但这种关系在接口定义本身无法直接反映出

-   **接口的配合关系**: 有些接口之间有一定的配合关系,在实现了其中一个之后,就要同时实现另一个.

# 六、编码和单元测试

关键任务:选择语言、工具翻译详细设计结果、测试模块

实现阶段文档：

    1、程序清单

2、单元测试报告

1.什么是单元测试？

1.1  单元测试的定义

定义:

    单元测试是对软件基本组成单元进行的测试。

时机:

    一般在代码完成后由开发人员完成,QA人员辅助.

概念:

    模块, 组件, 单元　

 

1.2  为何要进行单元测试?

 

尽早发现错误

错误发现越早,成本越低.

 

开发人员过于自信,后期复杂

 

度高,发现解决BUG困难.

 

检查代码是否符合设计和规范

1.3  单元测试的背景

 

开发流程时间表与修改Bug代价的关系图如下：

 

编程过程中，每写100行代码会犯150个错误

编程与编译运行结束后，每100行代码中大约残留有1-3个Bug

寻找与修改程序错误的代价占总体开发投资的40%-80%

Bug在整个研发流程中被发现的越早，修改的代价就越低

 

2.单元测试的目标和任务

 

2.1   单元测试的目标

 

目标是单元模块被正确编码

信息能否正确地流入和流出单元；

在单元工作过程中，其内部数据能否保持其完整性，包括内部数据的形式、内容及相互关系不发生错误，也包括全局变量在单元中的处理和影响。 

在为限制数据加工而设置的边界处，能否正确工作。

单元的运行能否做到满足特定的逻辑覆盖。 

单元中发生了错误，其中的出错处理措施是否有效

 

2.2  单元测试的任务

 

2.2.1    任务1：模块接口测试

 

检查模块接口是否正确，checklist:

 输入的实际参数与形式参数是否一致。

个数、属性、量纲

 调用其他模块的实际参数与被调模块的形参是否一致。

个数、属性、量纲

 全程变量的定义在各模块是否一致。

 外部输入、输出

文件、缓冲区、错误处理

 其它

2.2.2  任务2： 模块局部数据结构测试

 

检查局部数据结构完整性

Checklist:

 不适合或不相容的类型说明。

 变量无初值。

 变量初始化或默认值有错。

 不正确的变量名或从来未被使用过。

 出现上溢或下溢和地址异常。

 其它

2.2.3  任务3： 模块边界条件测试

 

检查临界数据处理的正确性

Checklist:

 普通合法数据的处理。

 普通非法数据的处理。

 边界值内合法边界数据的处理。

 边界值外非法边界数据的处理。

 其它

 

2.2.4  任务4： 模块独立执行通路测试

 

检查每一条独立执行路径的测试。保证每条语句被至少执行一次。

Checklist:

 算符优先级。

 混合类型运算。

 精度不够。

 表达式符号。

 循环条件，死循环。

 其它

2.2.5  任务5：模块的各条错误处理通路测试

 

预见、预设的各种出错处理是否正确有效。

Checklist:

 输出的出错信息难以理解。

 记录的错误与实际不相符。

 程序定义的出错处理前系统已介入。

 异常处理不当。

 未提供足够的定位出错的信息。

 其它

2.3  Microsoft对单元测试的理解

 

2.3.1  单元测试具体分类

 

验证产品实现符合功能规格书

验证产品代码运行的正确性

边缘条件测试

产品安全性测试

从已有Bug增加的回归测试

产品代码覆盖度测试(Code Coverage)

产品代码注射测试(Code Injection)

异常测试

产品速度性能的比较测试

产品极限情况测试

产品与国际标准的兼容性测试

产品与以前版本的操作系统，文件格式的兼容测试

同一产品不同版本共同运行的兼容性测试

产品在不同语言操作系统下的运行测试

2.3.2  单元测试具体流程

 

测试过程从产品设计开始

Spec Review 非常重要

微软产品Spec Review演示

Sharepoint Server的应用

测试代码编写由软件开发设计者(SDE)自己开始

DRT (Developer Regression Test)的重要性

没有相随的DRT， Feature Area不算开发完

DRT不全部编译并100%通过，不允许Check-in

测试组的测试不100%编译并100%通过0级测试(BVT), 70%通过1级测试，不允许Check-in

测试代码主体由软件测试工程师(SDET,STE)编写

测试从写软件测试规格书(Test Spec)开始

Test Spec必须通过PM，Dev与同组Tester共同开会研究通过

测试代码根据不同测试的情景分为0-4级的优先级

0级测试称为BVT (Build Verification Test)

在Dev主要的功能实现Check-in前,0-1级测试代码必须已由测试工程师完成

在Dev进行Check-in时，0级测试必须100%通过

在Dev进行Check-in时，1级测试必须至少有70%通过

Dev进行产品代码的Check-in

Test进行测试代码的Check-in

产品编译由Build团队每日进行

Test编译由测试团队在产品编译完成后进行

测试编译完成后，由测试自动化系统进行测试

在随后的代码优化与稳定期内，测试工程师编写2-4级测试代码，并报告产品Bug，Dev负责修改Bug，稳定并优化产品

 

3.静态测试技术的运用

 

3.1 静态测试技术的概念

 

静态测试技术： 不运行被测试程序，对代码通过检查、阅读进行分析。

 

三步曲：

 走查 （Walk Through）。

 审查 （Inspection）。

 评审 （Review）

 

3.2  编码的标准和规范

 

标准：建立起来必须遵守的规则。

规范：建议最佳做法，推荐更好方式。

 

实施标准和规范的原因：

 可靠性。

 可读性和可维护性。

 可移植性。

 

3.3  走查 （Walk Through）

 

定义：采用讲解、讨论和模拟运行的方式进行的查找错误的活动。

注意：

 引导小组成员在走查前通读设计和编码。

 限时，避免跑题。

 发现问题适当记录，避免现场修改。

 检查要点是代码是否符合标准和规范，是否有逻辑错误。

 

3.4 走查与审查的比较

 

3.5  评审 （Review）

 

定义：通常在审查会后进行，审查小组根据记录和报告进行评估。

 

注意：

 充分审查了所规定的代码，并且全部编码准则被遵守。

 审查中发现的错误已全部修改。

 

4.动态测试技术的运用

 

4.1  动态测试技术的概念

 

动态测试需要真正将程序运行起来，需要设计系列的测试用例保证测试的完整性和有效性。

 

 白盒测试

 黑盒（灰盒）测试

 

4.2  白盒测试方法

主要是逻辑驱动法和基本路径法。

  语句覆盖。

  判定覆盖。

  条件覆盖。

  判定/条件覆盖。

  条件组合覆盖。

  路径覆盖。

4.3  黑盒测试方法

运行单元程序有时需要基于被测单元的接口，开发相应的驱动模块和桩模块。

 驱动模块（drive）:对底层或子层模块进行测试所编写的调用这些模块的程序。

 桩模块（stub）：对顶层或上层模块进行测试时所编写的替代下层模块的程序。

 

4.4  黑盒常用方法

 等价类划分法                   

 边界值分析法                     三种数据：

 错误推测法                             \-- 正常数据

 因果图法                                \-- 错误数据

 功能图法                                \-- 边缘数据

另外还得考虑接口测试、性能测试、内存测试

 性能分析

 内存分析

 

5.调试与评估

调试与测试的对象及采用的方法有很大程度上的相似，调试还用到断点控制等排错方法，但其目的却完全不同。测试是为了找出软件中存在的缺陷，而调试是为了解决存在的缺陷。 

 软件单元功能与设计需求一致。 

 软件单元接口与设计需求一致。 

 能够正确处理输入和运行中的错误。 

 在单元测试中发现的错误已经得到修改并且通过了测试。 

 达到了相关的覆盖率的要求。 

 完成软件单元测试报告 

6.单元测试的过程与文档管理

6.1 单元测试的过程

过程:

在详细设计阶段完成单元测试计划。 

建立单元测试环境，完成测试设计和开发。 

执行单元测试用例，并且详细记录测试结果。 

判定测试用例是否通过。 

提交《单元测试报告》。

 

6.2  单元测试的文档

《软件需求规格说明书》、《软件详细设计说明书》 \-\-\--\> 《单元测试计划》 

《单元测试计划》、《软件详细设计说明书》 \-\-\--\> 《单元测试用例》 

《单元测试用例》文档及《软件需求规格说明书》、《软件详细设计说明书》 \-\--\> 《缺陷跟踪报告》/《缺陷检查表》  

《单元测试用例》、《缺陷跟踪报告》、《缺陷检查表》 \-\--\> 《单元测试检查表》 

评估\-\--\> 《单元测试报告》 

 

7. 单元测试常用工具简介

7.1  工具分类

 静态分析工具

 代码规范审核工具

 内存和资源检查工具

 测试数据生成工具

 测试框架工具

 测试结果比较工具

 测试度量工具

 测试文档生成和管理工具

# 七、综合测试

关键任务：通过各类型的测试（及相应的调试）是软件达到预定要求

测试报告（文档）：测试计划、测试方案、测试结果

概述

系统测试是为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误。测试的目的就是希望能以最少的人力和时间发现潜在的各种错误和缺陷。

系统测试应包含软件测试、硬件测试和网络测试，但后面更多的是软件测试。系统测试是保证系统质量和可靠性的关键，是对系统开发过程中的系统分析、设计、实施的最后复查，根据测试的概念和目的，在进行系统测试时赢遵循以下基本原则：

应尽早并不断地进行测试，测试不是在系统开发完之后才进行的。开发的各个阶段都有可能出现错误，因此测试应贯穿在开发的各个阶段。

测试工作应避免由原开发人员或小组承担，因为开发人员往往不愿否认自己的工作，另一方面开发人员很容易按照自己编程的思路来制定测试，具有局限性。

在设计测试方案时，不仅要确定输入数据，而且要根据系统功能来给出预期的输出结果。

在设计测试用例时，不仅要设计有效、合理的输入条件，也要包含不合理、失效的输入条件。

在测试程序时，不仅要检验程序是否做了该做的事情，还要关注程序是否做了不该做的事情。

严格按照测试计划进行，避免测试随意性。

妥善保存测试计划、测试用例，作为软件文档的组成部分。

测试例子都是精心设计出来的，可以为重新测试或追加测试提供基础。

测试过程

一个规范化的测试过程通常包含如下基本活动：

制定测试计划

充分考虑项目的开发时间和进度及其他客观因素来制定测试，使测试是可行的。计划内容主要有测试项目、进度安排、测试环境等内容。

编制测试大纲

大纲是测试活动的依据，它明确的规定了测试中针对系统的每一项功能或者特性所需完成的基本测试项目和测试标准。

根据测试大纲设计生成测试用例，产生测试设计文档

其中主要的是文档，它主要的内容有被测的项目、输入数据、测试过程和预期输出。

实施测试

测试的实施由一系列的测试周期组成，每个测试周期中测试人员都会依据测试大纲和测试用例对软件进行完整的测试。

生成测试报告

测试完成后需要形成对应的报告，用以对测试进行说明，列出测试得出的结论，指出其中的错误和缺陷。另外还可以提出建议等。

软件测试策略

测试策略指的是周密性的测试计划，一个测试策略必须包含测试计划、测试用例设计、测试执行及结果收集和评估。软件测试的策略应该具有足够的灵活性，以便促成测试方法的指定，同时又必须足够严格，能对项目进行准确的追踪。

有效的测试一般分为4步进行，下面简单介绍一下。

单元测试

又称为模块测试，在模块编写完成后且成功编译后就可以进行，单元测试主要侧重于模块中的逻辑和数据结构，一般使用白盒测试法，单元测试可以对多个模块同时进行。

测试内容

主要测试模块的5个特征：

模块接口------接口保障的是数据的流出流入

输入参数与形式参数在个数、属性、单位上是否一致

模块内调用其他模块时，给出的参数是否一致

调用标准函数时，参数是否正确

全局变量在各模块的定义是否一致

输入是否仅改变了形式参数

开关语句是否正确

规定的I/O格式是否正确

文件、内存等是否被正确的关闭、清理

数据结构------局部的数据结构错误是比较常见的错误

变量说明是否准确

是否存在使用未初始化变量

变量默认值是否正确

变量名是否存在拼写错误

执行路径------路径测试是一种基本任务，确保覆盖核心路径

由于实际中难以对每一条路径都穷举测试，因此需要进行的设计测试用例以发现计算及控制流方面的错误。

算术优先次序是否正确，精度是否足够，运算对象的类型是否合适，算法是否准确

逻辑运算符次序是否正确，循环终止是否正确，是否存在死循环，分支循环时出口是否正确

出错处理------好的设计应该能预测出错并提供合理的处理方法

边界条件------边界错误是编程中最常见的错误

测试方法

由于模块都不是独立运行的程序，各模块之间存在调用与被调用的关系，因此在对每个模块进行测试时，需要开发两种模块：

驱动模块，相当于主程序，它负责接收测试用例，并送至测试模块，回报输出结果。

桩模块，用来替代被测模块所调用的其他子模块，实现一个完全可控的测试。

通过驱动模块和桩模块将被测模块隔离，能完全控制各种情况的发生，从而更准确的测试模块的行为。

提高模块的内聚度可以有效的简化单元测试，如果一个模块只实现一个功能，那测试方案和数据的设计难度都会降低，而且更容易捕捉模块发生的错误。

集成测试

所谓集成测试就是将模块那系统设计说明要求，组合成一个整体进行测试。因为即使各个模块都通过了单元测试，仍然有可能在集成后出现问题。集成测试是构造软件体系结构的系统化技术，主要是为了发现与接口相关的错误。

通常，集成测试有两种方式： 非增量集成 与 增量集成 。前者就是分别测试各模块，再组合起来进行整体测试；而后者则是不断的往整体中添加模块来运行测试；非增量的好处在于可以与单元测试并行测试，但容易产生混乱，可能出现难以定位错误的问题。后者由于逐步扩大，因此更容易定位错误，且能更好的对接口进行充分的测试，并应用系统化的测试方法。下面简单介绍一些增量集成的方法：

自顶向下

模块的集成顺序由主控模块开始，沿着控制层逐渐往下，以深度优先或广度优先的方法将从属模块集成至系统中测试。简单的来说流程如下：

将主控模块作为测试驱动模块，用桩模块替换所有从属模块。

根据深度优先或广度优先的原则，每次用一个实际模块替换一个桩模块。

每替换进来一个实际模块均执行一遍测试集。

完成后接着用另一个实际模块替换另一个桩模块，以此类推，直至整个系统继承完毕。

在这个过程中，可以执行回归测试。

自底向上

这个与自顶向下方法是逆向的，它是从最底层构件开始集成。但略有不同的是，自底向上的方法按完成特定功能的簇为单位，在其之上放置驱动模块来实现的。最后再将各个簇集成即可。

相对于自顶向下来说，需要编写的测试代码更少，每个簇只需要一个驱动模块，而不是每个模块都需要对应的桩模块。

回归测试

每次集成一个新模块时，系统都发生了变更，这些变更可能导致原本正常的功能产生错误。因此回归测试就是再次执行已经执行过的测试集，以确保变更没有产生预期之外的副作用。

回归测试有助于保证不出现无意识行为导致额外的错误，主要包含3种类型的测试用例：

可以测试软件整体功能并具有代表性的测试用例

可能会受变更影响的部分的测试用例

着重测试发生变更的模块的测试用例

随着集成的进行，如果总是重新测试所有已经执行过的测试集，则回归测试集最终可能变得非常庞大，这是不现实的，因此回归测试的测试用例应当只着重于核心功能的测试。

冒烟测试

这是一种非常常见的测试方法，来自于电子工程领域，指的是当电路发生变更后，直接上电，如果短路冒烟了则证明改动出现了问题。可见这是一种测试耗时短的测试方式。

基本方式就是每天都构建整个软件产品并进行冒烟测试，期望尽早发现问题。

确认测试

当集成测试完成后就可以进行确认测试了，确认测试主要集中于用户可见和可识别的系统输出，即是软件系统的整体行为。

通过针对软件需求或规格说明来制定测试用例，确保软件系统的行为与需求或规格说明吻合。另外一方面，确认测试也要关注软件系统的配置评审工作，即检查软件、文档、数据是否齐全有序。

α测试与β测试

软件作为一种产品，由多个用户使用，但想让所有用户都进行正式的测试是不切实际的，因此多数软件开发者都使用α,β测试来查找似乎只有最终用户才能发现的错误。

α测试是由有代表性的最终用户在开发者的场所进行，软件在一般的环境下使用，开发者全程观看，并记录错误和使用问题。

β(beta)测试是在一个或多个最终用户的场所中进行，这种测试开发者通常不在现场，由最终用户记录测试过程中的所有问题并定期向开发者报告。这也是现在很多软件都经历过的测试方式。

β测试的一个变体称为客户验收测试，由客户执行一系列特定的测试，试图在正式验收前发现错误。验收测试的表现可能是非常正式的，有时候甚至会测试数个星期。

系统测试

系统测试是将已经确认的软件与计算机硬件、网络、外部设备等其他因素结合在一起进行的测试，这是一种贴近实际使用环境的测试。目的是发现系统整体是否与用户需求不符。

恢复测试

多数计算机系统必须有能力在发生错误后的一定时间内恢复运行，有些系统甚至要要求高容错能力，即处理错误不能使整个系统都停止运行。

恢复测试就是一种系统测试，通过各种方式强制让系统出现故障，并验证是否能从故障中恢复，并在约定时间内恢复运行，并且不造成任何损害。如果系统具备自我恢复的能力，则需要重新验证数据是否正确。如果是由人工干预的恢复，则要对恢复平均耗时进行评估。

安全性测试

在这种测试中，测试人员模拟非法入侵者，采取不同的方法尝试突破系统，安全性测试的准则是确认进行非法入侵所要花费的代价是否大于系统被攻破后泄露信息的价值。

压力测试

以非正常的数量、频率或容量等方式执行，使系统在大幅超出设计指标的情况运行以观察结果。本质上来说，压力测试也是要试图破坏软件系统以观察系统的行为。

另外有个变体称为敏感性测试，即在有效数据界限之内的一小部分可能会引起极端情况，甚至是产生错误。敏感性测试就是试图在有效的数据界限之中找到会引发系统不稳定的数据组合。

性能测试

在很多系统中，仅能提供所需功能但不符合性能要求是不能接受的，性能测试就是注重于测试运行的性能。性能测试也可以在任一开发过程中进行，如单元测试中进行以测试模块性能。但通常而言，只有当整个系统完全集成后的性能测试才能确定软件系统的真实性能。

性能测试常常与压力测试一同进行，而且需要硬件和软件作为工具。以严格的方式监控处理器、内存等各种资源的利用量。通过这样的方式，测试人员就可以发现什么情况下会导致效率降低甚至故障。

部署测试

也称为配置测试，是将软件在将要运行的每一种环境中执行的测试。另外还要检查面向客户的所有安装程序和文档。

# 八、软件维护

关键任务：通过各种必要的维护活动使系统持久地满足用户的需求

维护类型。

1、改正性维护：软件运行过程中发现错误进行维护

2、适应性维护：软件运行软件硬件环境变化进行的维护

3、完善性维护：用户要求改进或扩充软件进行的维护

4、预防性维护：为将来的维护作准备

1、软件维护是软件生存周期的最后一个阶段，是在软件交付使用后，为了改正错误或满足新的需要而修改软件的过程。软件维护工作的目标是：不断地、持续地改进、扩充、完善软件系统，以提高系统运行效率，并尽量延长系统的使用寿命，为用户创造更大的价值。

2、软件维护产生原因

（1）改正在特定使用条件下暴露出来的一些潜在的程序错误和设计缺陷。

（2）由于软件使用过程中数据环境发生变化或处理环境发生变化需要修改软件以适应这种变化。

（3）用户或数据处理人员在使用时常提出改进现有功能、增加新的功能，以及改善总体性能的要求，需要维护软件。

3、软件维护分类

（1）改正性维护

（2）适应性维护

（3）完善性维护

（4）预防性维护

4、软件维护技术

软件维护的技术包括：面向维护的技术和维护支援技术。

面向维护的技术是软件开发阶段用来减少错误，提高软件可维护性的技术。

维护支援技术是在软件维护阶段用来提高维护作业的效率和质量的技术。

5、软件维护的副作用

软件维护的副作用是指：由于维护或在文档化过程中其他一些不期望的行为引入的错误。副作用大致分为以下三类：

代码的副作用

数据副作用

文档副作用

6、软件再工程

软件再工程是目前预防性维护所采用的的主要技术，是为了以新形式重构已存在软件系统而实施的检测、分析、更替，以及随后构建新系统的工程活动。

软件再工程的目的是理解已存在的软件（包括规范、设计、实现），然后对该软件重新实现以期增强它的功能，提高它的性能，或降低它的实现难度，客观上达到维持软件的现有功能并为今后新功能的加入做好准备的目标。

7、必须在软件交付之前对整个软件配置进行复审，以减少文档副作用。

8、软件的可维护性、可使用性、可靠性是衡量软件质量的几个主要特性。

9、软件维护的费用增加的主要原因是维护的效率非常低。

10、维护申请报告是一种由用户产生的文档，它用作计划维护任务的基础。

11、采用手工方法开发软件只有程序而无文档，维护困难，这是一种非结构化维护，采用软件工程方法开发软件，各阶段均有文档，容易维护，这是一种结构化维护。

12、在软件维护的内容中，占维护活动工作量比例最高的是适应性维护。

13、当前时期软件维护的费用在总费用中的比例为60%\~70%

14、软件维护中大部分工作是由于用户的需求改变而引起的。

15、需求分析的修改不属于软件维护中的副作用。

16、软件可维护性是指纠正软件系统出现的错误和缺陷，以及为满足新的要求进行修改、扩充与压缩的容易程度。

17、软件使不同的系统约束条件和用户需求得到满足的容易程度是指兼容性。

18、可维护性的特性中，相互矛盾的是效率和可修改性。

19、影响软件维护成本的因素有哪些？

有形的软件维护成本可体现在花费了多少资金，而无形的软件维护成本则对软件有更大的影响。例如如下情况:

（1）一些合理的修复或修改请求如果不能得到及时安排，就会引起用户的不满。

（2）由于维护时的改动，在软件中引入潜在的错误，从而使软件的整体质量下降。

（3）把软件人员调到维护工作中，将会干扰软件开发工作。
